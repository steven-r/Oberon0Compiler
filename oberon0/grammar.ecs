#importMacros(Loyc.LLPG); // Only needed if compiling with Custom Tool = LeMP
using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Loyc;
using Loyc.Collections;
using Loyc.Syntax.Lexing; // for LexerSource, ISimpleToken<int>
using Loyc.Syntax;        // for ParserSource<Token>

using Oberon0.Compiler.Definitions;
using Oberon0.Compiler.Expressions;
using Oberon0.Compiler.Solver;
using Oberon0.Compiler.Statements;

namespace Oberon0.Compiler {
	// Please read this article to learn more about `unroll` and `replace`:
	// http://www.codeproject.com/Articles/995264/Avoid-tedious-coding-with-LeMP-Part
	//
	// A list of simple tokens to be represented literally (note: a slightly more
	// sophisticated approach is needed for keywords, see LLLPG Part 5 article.)
	replace (OPERATOR_TOKEN_LIST => (
		(">>", Shr),    // Note: as a general rule, in your lexer you should list 
		(">=", GE),
		(">",  GT),
		("<<", Shl),    // longer operators first. We will use this token list 
		("<=", LE),
		("<",  LT),
		(".",  Dot),
		("^",  Exp),
		("*",  Mul),
		("/",  Div),
		("+",  Add),
		("~",  Not),
		("-",  Sub),
		(";",  Semicolon),
		(":=", Assign),
		("=",  Equals),
		(":",  Colon),
		(",",  Comma),
		("#",  NotEquals),
		("(",  LParen),
		("[",  LBracket),
		("]",  RBracket),
		(")",  RParen)));

	
	using TT = TokenType; // Abbreviate TokenType as TT

	// Usually you'll need an enum containing the kinds of tokens you'll recognize.
	public enum TokenType
	{
		EOF = 0, // If you use EOF = 0, default(Token) represents End-Of-File (or end-of-input)
		
		// keywords
		Or,
		Mod,
		Module,
		If, Then, IfElse, Else,
		Begin, End,
		While, Do,
		Repeat, Until,
		Type, Var, Const,
		Array, Of, Record,
		Procedure,

		Id,
		Num,
		unroll ((_, TOKEN_NAME) in OPERATOR_TOKEN_LIST)
		{
			TOKEN_NAME; // inside 'unroll', must use ';' instead of ',' as separator
		},
		Unary, // -value
		Unknown
	}

	public struct Token : ISimpleToken<int>
	{
		public TokenType Type { get; set; }
		public object Value   { get; set; }
		public int StartIndex { get; set; }
		int ISimpleToken<int>.Type { get { return (int)Type; } }
		public override string ToString() {
			return string.Format("{0:G} -> {1}", Type, Value ?? "NULL");
		}
	}

	//--------------------------------------------------------------------------
	//-- LEXER -----------------------------------------------------------------
	//--------------------------------------------------------------------------

	partial class CalculatorLexer : IEnumerator<Token>
	{
		LLLPG (lexer(inputSource: Src, inputClass: LexerSource));
		
		// The Src object provides the API used by LLLPG. It holds three things: 
		// 1. The input data (Src.CharSource, a wrapper around the original
		//    input string that implements ICharSource) 
		// 2. The current input position (InputPosition), which is incremented
		//    whenever a character is matched.
		// 3. A "source file" object (Src.SourceFile, an implementation of
		//    ISourceFile). It which holds an optional file name, and can 
		//    convert a character index to a line+column pair with code like
		//    Src.SourceFile.IndexToLine(index).Line
		public LexerSource Src { get; set; }


		public CalculatorLexer(string text, string fileName = "") 
			{ Src = (LexerSource)text; }
		public CalculatorLexer(ICharSource text, string fileName = "") 
			{ Src = new LexerSource(text); }

		Token _tok;
		public Token Current
		{
			get { return _tok; }
		}

		#region IEnumerator
		// Three annoying extra things required by IEnumerator. To avoid writing
		// these functions, set the base class to EnumeratorBase<Token>. (But if 
		// you do that, MoveNext() must set the base class's Current property).
		object System.Collections.IEnumerator.Current
		{ 
			get { return Current; }
		}
		void System.Collections.IEnumerator.Reset()
		{
			Src.Reset();
		}
		void IDisposable.Dispose() 
		{
		}
		#endregion 

		public token bool MoveNext()
		{
			@[ (' '|'\t'|'\n'|'\r')* ];  // Skip spaces between tokens
			_tok.StartIndex = Src.InputPosition;
			_tok.Value = null;
			@[ { _tok.Type = TT.Num;    } Num
			 | { _tok.Type = TT.Num;    } ".nan" { _tok.Value = double.NaN; }
			 | { _tok.Type = TT.Num;    } ".inf" { _tok.Value = double.PositiveInfinity; }
			 | any punctuation // matches any of the punctuation rules
			 | IdOrKeyword
			 | error           // error branch - if input matches none of the above
			   { _tok.Type = TT.EOF; } (_ { _tok.Type = TT.Unknown; })? 
			 ];
			return _tok.Type != TT.EOF;
		}

		[k(9)]
		private token IdOrKeyword @[ 
			  "ARRAY"	EndId {_tok.Type = TT.Array;}
			/ "BEGIN"	EndId {_tok.Type = TT.Begin;}
			/ "CONST"	EndId {_tok.Type = TT.Const;}
			/ "DO"		EndId {_tok.Type = TT.Do;}
			/ "IF"		EndId {_tok.Type = TT.If; }
			/ "DIV"		EndId {_tok.Type = TT.Div; }
			/ "END"		EndId {_tok.Type = TT.End;}
			/ "ELSE"	EndId {_tok.Type = TT.Else; }
			/ "ELSIF"	EndId {_tok.Type = TT.IfElse; }
			/ "MOD"		EndId {_tok.Type = TT.Mod; }
			/ "MODULE"	EndId {_tok.Type = TT.Module; }
			/ "OF"		EndId {_tok.Type = TT.Of; }
			/ "RECORD"	EndId {_tok.Type = TT.Record; }
			/ "REPEAT"	EndId {_tok.Type = TT.Repeat; }
			/ "PROCEDURE"	EndId {_tok.Type = TT.Procedure; }
			/ "THEN"	EndId {_tok.Type = TT.Then; }
			/ "TYPE"	EndId {_tok.Type = TT.Type; }
			/ "UNTIL"		EndId {_tok.Type = TT.Until; }
			/ "VAR"		EndId {_tok.Type = TT.Var; }
			/ "WHILE"	EndId {_tok.Type = TT.While; }
		    / Id              {_tok.Type = TT.Id; }
		];

		// If a keyword is followed by a letter or number then it is NOT a keyword.
		// So this rule is used to cause LLLPG to verify that there is no letter or
		// number after the keyword. 'inline' ensures that the effect of this rule 
		// internalized to IdOrKeyword, and `extern` suppresses generating the empty 
		// method that would be created for this rule.
		extern inline token EndId @{ (~('a'..'z'|'A'..'Z'|'0'..'9'|'_') | EOF) => };

		private token Id() @[
			('a'..'z'|'A'..'Z'|'_')
			('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
			{ _tok.Value = Src.CharSource.Slice(_tok.StartIndex, Src.InputPosition - _tok.StartIndex).ToString(); }
		];

		private token Num() @[
			'0'..'9'+
			('.' '0'..'9'+)?
			{ _tok.Value = Src.CharSource.Slice(_tok.StartIndex, Src.InputPosition - _tok.StartIndex).ToString(); }
		];

		unroll ((TEXT, TOKEN_NAME) in OPERATOR_TOKEN_LIST)
		{
			extern inline punctuation rule TOKEN_NAME() { 
				@[ TEXT ]; _tok.Type = TT.TOKEN_NAME;
			}
		}
	}

	//--------------------------------------------------------------------------
	//-- PARSER ----------------------------------------------------------------
	//--------------------------------------------------------------------------

	public partial class CompilerParser
	{
		public ParserSource<Token> Src { get; set; } // LLLPG API

		public Module module {get; set;}

		public Module Calculate(string input)
		{
			Token EofToken = new Token { Type = TT.EOF };

			var lexer = new CalculatorLexer(input);
			// ParserSource accepts any IEnumerator<Token> for its first parameter
			Src = new ParserSource<Token>(lexer, EofToken, lexer.Src.SourceFile) { 
				TokenTypeToString = tt => ((TT)tt).ToString(),
				ErrorSink = new MessageSinkFromDelegate((type, ctx, msg, args) => {
                    MessageSink.Console.Write(type, ctx, msg, args);
                    throw new LogException(new LogMessage(type, ctx, msg, args));
                })
			};
			var result = Module();
			// emit an error if we reach end of expression before end-of-input
			Src.Match((int) TT.EOF);
			return result;
		}

		
		LLLPG (parser(laType: TokenType, matchType: int, 
		              inputSource: Src, inputClass: ParserSource<Token>));

		unroll ((TEXT, TOKEN_NAME) in OPERATOR_TOKEN_LIST) {
			alias(TEXT = TT.TOKEN_NAME);
		}

		private rule RecordElement(RecordTypeDefinition typeDefinition, Block block) @[
			i:=TT.Id ":" v:=VarTypeReference(block) 
			{
				string name = i.Value.ToString();
				if (typeDefinition.Elements.Any (x => x.Name == name)) {
					Src.Error(0, "The element '{0}' has been defined already", name);
				} 
				else
				{
					typeDefinition.Elements.Add(new Declaration(i.Value.ToString(), v));
				}
			}
		];

		private rule TypeDefinition VarTypeReference(Block block) @[
		    i:=TT.Id { 
				$result = block.LookupType(i.Value.ToString()); 
				if ($result == null) Src.Error(0, "Type '{0}' not found", i.Value.ToString()); 
			}
			| TT.Array e:=SimpleExpression(block) TT.Of t:=VarTypeReference(block) {
				var constex = ConstantSolver.Solve(e, block) as ConstantIntExpression;
				if (constex == null) {
					Src.Error(0, "The array size must resolve as INTEGER");
				}
				else {
					$result = new ArrayTypeDefinition(constex.ToInt32(), t);
				}
			}
			| TT.Record { var rtd = new RecordTypeDefinition(); }
				( RecordElement(rtd, block) ";") +
			  TT.End { $result = rtd; }
		];

		private rule IdListElement(Block block, List<string> idList) @[
			n:=TT.Id { 
				string name = n.Value.ToString();
				if (block.Declarations.Any (x => x.Name == name) || idList.Any(x => x == name)) {
					Src.Error(0, "The identifier {0} has been defined already", name);
				} 
				else
				{
					idList.Add(name);
				}
			}
		];

		private rule List<string> IdList(Block block) @[
			{ List<string> ids = new List<string>(); }
			(
			 IdListElement(block, ids)
			 ( "," IdListElement(block, ids) ) *
			)
			{return ids;} 
			| error { Src.Error(0, "An identifier is expected here"); return null;}
		];

		private rule SingleVarDeclaration(Block block) @[
			ids:=IdList(block)
			":" t:=VarTypeReference(block) {
				foreach(string v in ids)
					block.Declarations.Add(new Declaration(v, t, block));
			}
		];

		private rule SimpleTypeDeclaration(Block block) @[
			i:=TT.Id "=" v:=VarTypeReference(block) {
				string name = i.Value.ToString();
				if (block.Types.Any (x => x.Name == name)) {
					Src.Error(0, "The type '{0}' has been defined already", name);
				} 
				else
				{
					v.Name = i.Value.ToString();
					block.Types.Add(v);
				}
			}
		];

		private rule SingleConstDeclaration(Block block) @[
			i:=TT.Id "=" e:=SimpleExpression(block) {
				string name = i.Value.ToString();
				if (block.Declarations.Any (x => x.Name == name)) {
					Src.Error(0, "The identifier '{0}' has been defined already", name);
				} 
				else
				{
					var constex = ConstantSolver.Solve(e, block) as ConstantExpression;
					block.Declarations.Add(new ConstDeclaration(name, new SimpleTypeDefinition(constex.TargetType, name), constex, block));
				}
			}
		];

		private rule ProcedureBody(FunctionDeclaration proc) @[
			Declarations(proc.Block)
			( TT.Begin StatementSequence(proc.Block) ) ?
			TT.End n:=TT.Id
			{ string name = n.Value.ToString();
			  if (name != proc.Name) {
				Src.Error(0, "END name does not match procedure declaration");
			  }
			}
		];

		private rule FPSection(FunctionDeclaration proc) @[
			{bool isVar = false; }
			(TT.Var { isVar= true;}) ? 
			n:=TT.Id ":" v:=VarTypeReference(proc.Block)
			{
				string name = n.Value.ToString();
				proc.Parameters.Add(new ProcedureParameter(name, v, isVar)); 
			}
		];

		private rule FormalParameters(FunctionDeclaration proc) @[
			FPSection(proc) 
			( ";" FPSection(proc) ) * 
		];

		private rule FunctionDeclaration ProcedureHeading(Block block) @[
			TT.Procedure n:=TT.Id 
			{ 
				string name = n.Value.ToString();
				if (block.Procedures.Any(x => x.Name == name))
				{
					Src.Error(0, "This procedure has been defined before");
				}
				$result = new FunctionDeclaration(name, block);
			}
			( "(" FormalParameters(result) ")" ) ?
		];

		// procedure
		private rule ProcedureDeclaration(Block block) @[
			p:=ProcedureHeading(block) ";" ProcedureBody(p)
			{
				block.Procedures.Add(p);
			}
		];
		
		private rule Declarations(Block block) @[
			( TT.Const ( SingleConstDeclaration(block) ";" ) + ) ?
			( TT.Type ( SimpleTypeDeclaration(block) ";" ) + ) ?
			( TT.Var ( SingleVarDeclaration(block) ";" ) + ) ?
			( ProcedureDeclaration(block) ";" ) *
		];

		private rule List<Expression> ParameterList(Block block) @[
			{ $result = new List<Expression>(); }
			( r:=RelationalExpression(block) { $result.Add(r); }
				( "," r1:RelationalExpression(block) { $result.Add(r1); }) * ) ? 
		];

		// Expressions
		private rule Expression Term(Block block) @[
			{ string name = string.Empty; var pl = new List<Expression>(); }
			( 
			( 
				t:=TT.Id { name = t.Value.ToString(); }
				s:=Selector(block)
				( "(" pl1:ParameterList(block) { if (pl1 != null) pl.AddRange(pl1); } ? ")" 
				{ FunctionDeclaration f = block.LookupFunction(name);
					if (f == null) { Src.Error(0, "There's no function named '{0}'", name); }
					if (f.ReturnType == BaseType.VoidType) {
						Src.Error(0, "You cannot call procedure '{0}' as a function", name);
					}
					if (f.Parameters.Count != pl.Count) {
						Src.Error(0, "The number of parameters doesn't match (Expected {0}, found {1})", f.Parameters.Count, pl.Count);
					}
					if (s.Count > 0) { Src.Error(0, "Using selectors for functions is not allowed"); }
					$result = new FunctionCallExpression(f, block, pl.ToArray());
				}
				) ?
				{  
					if ($result == null) {
						$result = VariableReferenceExpression.Create(block, name, s); 
						if ($result == null) { Src.Error(0, "The variable {0} is not known", name); }
					}
				}
			)
			| t:=TT.Num { $result = ConstantExpression.Create(t.Value); }
			| "(" result:SimpleExpression(block) ")"
			| "~" n:=Term(block) {$result = BinaryExpression.Create(TT.Not, n, new ConstantBoolExpression(false)); }
			| error     { $result = null; Src.Error(0, "Expected identifer, number, or (parens)"); }
			)
			greedy 
			[ "^" e:=Term(block) { $result = BinaryExpression.Create(TT.Exp, result, e); } ]*
		];

		private rule Expression PrefixExpr(Block block) @[
			"-" t:=Term(block) { $result = BinaryExpression.Create(TT.Sub, ConstantExpression.Create(0), t); }
			| t:=Term(block) { $result = t; }
		];

		private rule Expression MulExpr(Block block) @[
			result:PrefixExpr(block)
			(op:=("*"|"/"|TT.Div|TT.Mod) rhs:=PrefixExpr(block) { $result = BinaryExpression.Create(op.Type, $result, rhs); })*
		];

		private rule Expression SimpleExpression(Block block) @[
			result:MulExpr(block)
			(op:=("+"|"-") rhs:=MulExpr(block) { $result = BinaryExpression.Create(op.Type, $result, rhs); })*
		];

		private rule Expression RelationalExpression(Block block) @[
			result:SimpleExpression(block)
			( t:=("<" | "<=" | ">" | ">=" | "=" | "#") 
				  rhs:=SimpleExpression(block) { $result = BinaryExpression.Create(t.Type, $result, rhs); } 
			) ?
		];

		// statements
		private rule StatementSequence(Block block) @[
			SingleStatement(block) ( ";" SingleStatement(block) ) *
		];

		private rule AssignmentStmt(string varName, VariableSelector selector, Block block) @[
			{
				var variable = block.LookupVar(varName);
				if (variable == null) {
					Src.Error(0, "Variable '{0}' not found", varName);
				}
			}
			e:=RelationalExpression(block)
			{
				Console.WriteLine($"Assignment {varName} := {e.GetType().Name}");
				block.Statements.Add(new AssignmentStatement{Variable = variable, Expression = e});
			}
		];

		private rule VariableSelector Selector(Block block) @[
			{ $result = new VariableSelector(); }
			( "." i:=TT.Id  { $result.Add(new IdentifierSelector(i.Value.ToString())); }
			  | "[" e:=SimpleExpression(block) "]" 
							{ 
								if (e.TargetType != BaseType.IntType) {
									Src.Error(0, "Error offset needs to be integer type");
								}
								$result.Add(new IndexSelector(e)); 
							}
			) *
		];

		private rule ProcedureCall(string name, Block block) @[
			{ 
				FunctionDeclaration p = block.LookupFunction(name);
				if (p == null) { Src.Error(0, "Procedure {0} not found", name); }
				List<Expression> pl = new List<Expression>(); 
			}
			( "(" pl1:ParameterList(block) ")" { pl.AddRange(pl1); } ) ?
			{ 
				if (pl.Count != p.Parameters.Count) {
					Src.Error(0, "Wrong number of parameters to call {0}. Expected {1}, found {2}", name, p.Parameters.Count, pl.Count);
				}
				block.Statements.Add(new ProcedureCallStatement(p, block, pl));
			}
		];

		private rule AssignmentOrCall(Block block) @[
			v:=TT.Id 
			s:=Selector(block)
			( ":=" AssignmentStmt(v.Value.ToString(), s, block) 
			| ProcedureCall(v.Value.ToString(), block) {
				if (s.Count > 0) { Src.Error(0, "Procedure calls do not expect a selector"); }
			}
			) 
		];

		private rule IfStmt(Block block) @[
			{ IfStatement ifs = new IfStatement(block); }
			c:=RelationalExpression(block) TT.Then
				{ Block thenBlock = new Block(); thenBlock.Parent = block; }
			StatementSequence(thenBlock) { ifs.Conditions.Add(c); ifs.ThenParts.Add(thenBlock); }
			( TT.IfElse c1:=RelationalExpression(block) TT.Then 
				{ thenBlock = new Block(); thenBlock.Parent = block; }
			  StatementSequence(thenBlock)
				{ ifs.Conditions.Add(c1); ifs.ThenParts.Add(thenBlock); }
			) *
			( TT.Else 
				{ Block elseBlock = new Block(); elseBlock.Parent = block; }
			  StatementSequence(elseBlock) {
				ifs.ElsePart = elseBlock;
			  }
			) ?
			TT.End
			{ block.Statements.Add(ifs); }
		];

		private rule WhileStmt(Block block) @[
			{ WhileStatement w = new WhileStatement(block); }
			e:=RelationalExpression(block) TT.Do { w.Condition = e; }
				StatementSequence(w.Block)
			TT.End
		];

		private rule RepeatStmt(Block block) @[
			{ RepeatStatement r = new RepeatStatement(block); }
			StatementSequence(r.Block)
			TT.Until e:=RelationalExpression(block) { r.Condition = e; }
			TT.End
		];

		private rule SingleStatement(Block block) @[
			AssignmentOrCall(block)
			| TT.If IfStmt(block)
			| TT.While WhileStmt(block)
			| TT.Repeat RepeatStmt(block)
			| { Src.Error(0, "Statement expected"); } 
		];

		// Module
		rule Module Module() @[
			{ $result = module = new Module(); }
			TT.Module m:=TT.Id TT.Semicolon Declarations(result.Block) 
			( TT.Begin 
				StatementSequence(module.Block) ) ?
			TT.End e:=TT.Id 
			{ 
				string endName = e.Value.ToString();
				$result.Name = m.Value.ToString(); 
				if (endName != $result.Name) {
					Src.Error (0, "The module name {0} does not match {1}", $result.Name, endName);
				}
			}
			TT.Dot
		];
	}
} // end namespace